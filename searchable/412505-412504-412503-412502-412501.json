[
 {
  "author": "zongaro", 
  "date": "2006-06-07T19:54:33.008408Z", 
  "msg": [
   "Part of fix for XALANJ-2294.  When building a KeyIndex for keys or for IDs in", 
   "a document, the KeyIndex needs to be informed of the root node of the document", 
   "so that it can retrieve only nodes that are in the same document as the context", 
   "node and of node handles for nodes rather than the node identities, which will", 
   "be reused across different documents.", 
   "Reviewed by Christine Li (jycli () ca ! ibm ! com)"
  ], 
  "revision_id": "412505"
 }, 
 {
  "author": "zongaro", 
  "date": "2006-06-07T19:54:24.216942Z", 
  "msg": [
   "Part of fix for XALANJ-2294 and XALANJ-2295.", 
   "Each KeyIndex for a particular key or for the id function was set up with a", 
   "Hashtable mapping Strings to nodes.  However, the set of nodes returned are", 
   "only supposed to be those in the same input document as the context node.  The", 
   "code was accepting nodes as node IDs and putting them all into the same table,", 
   "so node IDs from different documents were being mixed together.  Fixed this by", 
   "adding another Hashtable from the root node of a document to the Hashtable that", 
   "maps Strings to node handles in that document.  This affects insertion of nodes", 
   "into the KeyIndex (in add) and look-up of nodes for patterns (in containsID,", 
   "containsKey, getDOMNodeById).", 
   "Generated byte code previously looked up nodes to be retrieved by a reference", 
   "to the key or id function by cloning an IntegerArray containing the first set", 
   "of nodes and merging in subsequent nodes retrieved.  The generated code", 
   "contained any required looping code to loop over nodes in a node set that", 
   "appeared in a call to key or id.  The effect of all this was that every node in", 
   "the resulting node set was processed at least once, regardless of whether all", 
   "the node returned were actually used - they might not need to be if a positional", 
   "predicate is used, for instance.", 
   "The old KeyIndex.lookupId and KeyIndex.lookupKey are now deprecated, but", 
   "preserved for any previously compiled translets.  Instead, new code will use", 
   "the KeyIndex.getKeyIndexIterator methods to get an iterator that will return the", 
   "nodes for a particular reference to the key or id function.", 
   "The iterator returned by getKeyIndexIterator is an instance of an inner class -", 
   "KeyIndex.KeyIndexIterator - which extends the new MultiValuedNodeHeapIterator.", 
   "Each node in the heap refers to an IntegerArray that contains the nodes for", 
   "each key value or id value that was looked up.  It's sensitive to the context", 
   "node (or more importantly, the root of the context node) and retrieves node", 
   "handles for the function reference lazily to avoid unnecessarily greedy and", 
   "potentially duplicate processing of the nodes.", 
   "Also, fix for XALANJ-2292.  The byte code generation assumed that if the", 
   "second argument to a reference to the key function was not a node set or a", 
   "string, that it had to be converted to a string.  However, if the argument is", 
   "a parameter whose value is a node set, all the nodes in the node set should", 
   "play a role in computing the result of the function, not just the first.", 
   "The KeyIndex.KeyIndexIterator is responsible for processing the argument to the", 
   "key or id function, iterating over nodes in a node set if required, rather than", 
   "leaving that responsibility to generated byte code, because we don't generally", 
   "know whether the argument will be an iterator.", 
   "Reviewed by Christine Li (jycli () ca ! ibm ! com)"
  ], 
  "revision_id": "412504"
 }, 
 {
  "author": "zongaro", 
  "date": "2006-06-07T19:54:17.833976Z", 
  "msg": [
   "Part of fix for XALANJ-2294.  Refactored UnionIterator so that it is derived", 
   "from a new MultiValuedNodeHeapIterator class.  The latter is responsible for", 
   "the basic management of a heap, each of whose nodes contains multiple DTM", 
   "node handles, while the former handles the specific case of implementing a", 
   "union of other iterators.", 
   "In the original heap implementation of UnionIterator, each node contained a", 
   "DTMAxisIterator, but in MultiValuedNodeHeapIterator, each node contains", 
   "something that returns node handles; that doesn't have to be a DTMAxisIterator,", 
   "though in the of UnionIterator, it still is.", 
   "Reviewed by Christine Li (jycli () ca ! ibm ! com)"
  ], 
  "revision_id": "412503"
 }, 
 {
  "author": "zongaro", 
  "date": "2006-06-07T19:54:11.137713Z", 
  "msg": [
   "Part of fix for XALANJ-2294.  The way that SAXImpl.getIterator is used in", 
   "generated code makes it clear that XSLTC always expects the iterator to point to", 
   "the root of the DTM, rather than being affected by calls to setStartNode.  Added", 
   "the \"constant\" flag with a value of true on SingletonIterator constructed by", 
   "getIterator.", 
   "Also, added support for ROOT axis in getAxisIterator and getTypedAxisIterator.", 
   "Reviewed by Christine Li (jycli () ca ! ibm ! com)"
  ], 
  "revision_id": "412502"
 }, 
 {
  "author": "zongaro", 
  "date": "2006-06-07T19:54:03.908231Z", 
  "msg": [
   "Part of fix for XALANJ-2295.  Changed DupFilterIterator.setStartNode to take", 
   "advantage of the fact that if the source iterator is a KeyIndex, it will", 
   "return its nodes in document order, so no additional IntegerArray.sort operation", 
   "is necessary.", 
   "Reviewed by Christine Li (jycli () ca ! ibm ! com)"
  ], 
  "revision_id": "412501"
 }
]