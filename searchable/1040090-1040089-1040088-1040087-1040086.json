[
 {
  "author": "jukka", 
  "date": "2010-11-29T12:45:14.654861Z", 
  "msg": [
   "JCR-2820: FineGrainedISMLocking problems", 
   "Use the transaction id to identify the current thread for locking purposes."
  ], 
  "revision_id": "1040090"
 }, 
 {
  "author": "reto", 
  "date": "2010-11-29T12:43:43.527727Z", 
  "msg": [
   "CLEREZZA-356: added support for WebRenderingServices"
  ], 
  "revision_id": "1040089"
 }, 
 {
  "author": "gpetracek", 
  "date": "2010-11-29T12:36:01.650406Z", 
  "msg": [
   "EXTCDI-60 fallback if there isn't a view-root"
  ], 
  "revision_id": "1040088"
 }, 
 {
  "author": "zoe", 
  "date": "2010-11-29T12:32:22.148831Z", 
  "msg": [
   "ARIES-502"
  ], 
  "revision_id": "1040087"
 }, 
 {
  "author": "dag", 
  "date": "2010-11-29T12:28:54.890139Z", 
  "msg": [
   "DERBY-4741 Make Derby work reliably in the presence of thread interrupts", 
   "Patch derby-4741-c-01-nio: closes two corner cases I have", 
   "observed when stress testing the RAFContainer4 recovery mechanism. It", 
   "also does some other small cleanups. Regressions ran OK.", 
   "RAFContainer:", 
   "If we receive an interrupt when the container is first being opened", 
   "(i.e. during RAFContainer.run (OPEN_CONTAINER_ACTION) ->", 
   "getEmbryonicPage), recovery will fail because currentIdentity needed", 
   "in RAFContainer4#recoverContainerAfterInterrupt hasn't yet been", 
   "set.", 
   "RAFContainer4:", 
   "If a stealthMode read is interrupted and is recovering the container,", 
   "it erroneously increments threadsInPageIO just before exiting to retry", 
   "IO. This leads to a break in the invariant that threadsInPageIO be 0", 
   "when all threads are done, causing issue (hang) down the line.", 
   "If, when we are reopening the container, the read being done during", 
   "that operation (getEmbryonicPage), that stealth mode read will also", 
   "lead to a (recursive) recovery. We have to catch this case by adding a", 
   "\"catch (InterruptDetectedException e)\" just after the call to", 
   "openContainer, not by testing the interrupt flag as presently done,", 
   "since the recovery inside the recursive call to", 
   "getEmbryonicPage/readPage will already have cleared the flag and done", 
   "recovery.", 
   "When giving up reopening the container for some reason, we also forgot", 
   "to decrement threadsInPageIO."
  ], 
  "revision_id": "1040086"
 }
]