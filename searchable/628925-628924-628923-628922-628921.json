[
 {
  "author": "gpetracek", 
  "date": "2008-02-18T23:49:44.192526Z", 
  "msg": [
   "TRINIDAD-935"
  ], 
  "revision_id": "628925"
 }, 
 {
  "author": "knopp", 
  "date": "2008-02-18T23:48:39.634606Z", 
  "msg": [
   "WICKET-1356", 
   "revert setMetaData change"
  ], 
  "revision_id": "628924"
 }, 
 {
  "author": "knopp", 
  "date": "2008-02-18T23:48:18.625163Z", 
  "msg": [
   "revert setMetaData change"
  ], 
  "revision_id": "628923"
 }, 
 {
  "author": "knopp", 
  "date": "2008-02-18T23:48:03.321970Z", 
  "msg": [
   "revert setMetaData change"
  ], 
  "revision_id": "628922"
 }, 
 {
  "author": "mharwood", 
  "date": "2008-02-18T23:39:12.409852Z", 
  "msg": [
   "Additional thread safety around filter creation - old code could create duplicate CachingWrapperFilter if thread1 gets cache miss and thread 2 has a cache miss before thread1 populates cache with new CachingWrapperFilter.", 
   "Synchronization cost around whole method is OK here because Filter object construction should be a lightweight call.", 
   "Note: CachingWrapperFilter currently has a similar bug in bits() method but adding \"synchronized\" around that whole method would not be a solution there because of the cost of evaluating filter.bits and the unnecessary blocking effect this would have on threads using different readers to the thread with the lock."
  ], 
  "revision_id": "628921"
 }
]