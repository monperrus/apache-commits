[
 {
  "author": "asmuts", 
  "date": "2002-05-13T18:31:41.000000Z", 
  "msg": [
   "Cleaned and commented"
  ], 
  "revision_id": "223939"
 }, 
 {
  "author": "asmuts", 
  "date": "2002-05-13T18:25:42.000000Z", 
  "msg": [
   "Cleaned and commented"
  ], 
  "revision_id": "223938"
 }, 
 {
  "author": "asmuts", 
  "date": "2002-05-13T18:12:27.000000Z", 
  "msg": [
   "Eliminated teh race condition. The creation of the key array is using the same lock as remove and put.", 
   "The shrinker uses the array rather than the set directly.  The cache then manages the removal.  Should be fine."
  ], 
  "revision_id": "223937"
 }, 
 {
  "author": "asmuts", 
  "date": "2002-05-13T16:25:42.000000Z", 
  "msg": [
   "Modified and tested shrinking.", 
   "The concurrent modification exceptions were eating memory.", 
   "The shrinker was also removing items via the iterator, but the linked list still held references to them.", 
   "I reduced the chance of the exceptions, but there is still a race condition in the creation of the Array of keys.", 
   "The removals and gets go through the memory cache now.", 
   "We need to get rid of the MemoryCache interface and use the IMemoryCache interface.", 
   "There is a small memory usage by the shrinker, but the garbage collector is reclaiming it successfully.", 
   "I don't think there are any more memory leaks.  I'll test some more and then clean up."
  ], 
  "revision_id": "223936"
 }, 
 {
  "author": "asmuts", 
  "date": "2002-05-13T14:47:06.000000Z", 
  "msg": [
   "made sure the disk path is trimmed to reduce stupid errors in configuration"
  ], 
  "revision_id": "223935"
 }
]