[
 {
  "author": "mturk", 
  "date": "2006-10-02T17:06:15.809986Z", 
  "msg": [
   "Bump MMN for r451575."
  ], 
  "revision_id": "452125"
 }, 
 {
  "author": "chirino", 
  "date": "2006-10-02T17:05:23.055054Z", 
  "msg": [
   "Latest export from confluence"
  ], 
  "revision_id": "452124"
 }, 
 {
  "author": "chirino", 
  "date": "2006-10-02T17:05:15.550059Z", 
  "msg": [
   "Latest export from confluence"
  ], 
  "revision_id": "452123"
 }, 
 {
  "author": "danj", 
  "date": "2006-10-02T17:04:09.063759Z", 
  "msg": [
   "branch of 2.0.0 release so that work can begin on 2.1.0."
  ], 
  "revision_id": "452122"
 }, 
 {
  "author": "mriou", 
  "date": "2006-10-02T17:03:28.227916Z", 
  "msg": [
   "[ODE-51] This is a tricky one. The replaceContent / replaceElement semantic of assign presupposes that we can have a proper lvalue pointer on the lvalue node tree. However when we're doing XPath evaluation, we're also expected to return simple types when require (to allow simple computations like '1+1=2'). Ideally we should always return the right java mapped simple type when selecting an rvalue and always a nodeset when selecting an lvalue. However resolvers have no idea what we're selecting for.", 
   "This fix will make things work for all cases when the lvalue isn't computable (not an integer or a float for example), which is the most common (it's rare to have a number selected as an lvalue). However there's always edge cases."
  ], 
  "revision_id": "452121"
 }
]