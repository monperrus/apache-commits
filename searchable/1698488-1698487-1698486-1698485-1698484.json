[
 {
  "author": "gstein", 
  "date": "2004-09-06T16:19:24.595265Z", 
  "msg": [
   "Move the de-chunking logic into its own bucket. The previous code did not", 
   "read the CRLF chunk data terminator; making it do so would have seriously", 
   "convoluted the logic in the response bucket.", 
   "Also fixed a problem in handle_response() where it did not properly drain", 
   "the response bucket. As a result, it was possible to return to the poll", 
   "loop, yet nothing was going to come back. When the connection finally", 
   "timed out, the handler was called again and read the rest of the response.", 
   "* test/serf_get.c:", 
   "(handle_response): fully drain the response bucket before returning. use", 
   "fwrite() to print to stdout, rather than dup'ing the value into a pool.", 
   "* buckets/dechunk_buckets.c: new bucket type. pretty standard state", 
   "machine style of bucket.", 
   "* buckets/response_buckets.c:", 
   "(response_context_t): add a dechunk bucket", 
   "(serf_bucket_response_create): clear the new dechunk field so we know", 
   "whether we have to destroy it later.", 
   "(serf_response_destroy_and_data): destroy the chunked bucket, if created", 
   "(fetch_chunk_size): removed. no longer needed.", 
   "(run_machine): create a dechunk bucket if the response is chunked", 
   "(wait_for_body): simplify since we don't have to deal with chunked", 
   "bodies here.", 
   "(serf_response_read): simply defer to the chunked bucket when needed", 
   "* serf_bucket_types.h: add standard declarations for the dechunk bucket.", 
   "* Makefile: add the dechunk bucket"
  ], 
  "revision_id": "1698488"
 }, 
 {
  "author": "gstein", 
  "date": "2004-09-06T14:48:37.204827Z", 
  "msg": [
   "Create a general line buffering structure and supporting functions. This", 
   "is all factored out of the response buckets.", 
   "Note: this system implies that data WILL be copied; we'll need to adjust", 
   "the parameters a bit to enable copy-avoidance. But this pass is merely to", 
   "relocate private code into a more generally useful location.", 
   "* serf.h:", 
   "(serf_linebuf_t): utility structure for buffering lines", 
   "(serf_linebuf_init): initialize a linebuf", 
   "(serf_linebuf_fetch): fetch a line from a bucket", 
   "* buckets/buckets.c:", 
   "(serf_linebuf_init, serf_linebuf_fetch): implement", 
   "* buckets/response_buckets.c:", 
   "(response_context_t): replace fields with linebuf. all users changed.", 
   "(serf_bucket_response_create): call serf_linebuf_init() on the new", 
   "linebuf structure in our context.", 
   "(fetch_line): factored out to serf_linebuf_fetch()."
  ], 
  "revision_id": "1698487"
 }, 
 {
  "author": "gstein", 
  "date": "2004-09-06T14:20:04.140651Z", 
  "msg": [
   "Small change to enforce CRLF for chunk sizes. We'll remain flexible for", 
   "other line terminations.", 
   "* buckets/response_buckets.c:", 
   "(fetch_line): drop the \"stream\" parameter, since we can just get it from", 
   "the context. add an \"acceptable\" param to specify the line terminator.", 
   "(fetch_chunk_size): only accept CRLF for chunk sizes", 
   "(fetch_headers): accept any newline terminator for headers.", 
   "(run_machine): accept any newline terminator for the Status-Line."
  ], 
  "revision_id": "1698486"
 }, 
 {
  "author": "gstein", 
  "date": "2004-09-05T13:12:55.706546Z", 
  "msg": [
   "Add some bucket use and lifecycle tracking code.", 
   "* serf.h:", 
   "(SERF_DEBUG_BUCKET_USE): preprocessor symbol to control all the logic", 
   "around bucket tracking.", 
   "(SERF__RECREAD): internal macro to record read status for a bucket", 
   "(serf_bucket_read, serf_bucket_readline, serf_bucket_read_iovec,", 
   "serf_bucket_read_for_sendfile): use SERF__RECREAD", 
   "(serf_debug__record_read, serf_debug__entered_loop,", 
   "serf_debug__closed_conn, serf_debug__bucket_destroy): internal", 
   "functions to implement the bucket use/lifecycle tracking.", 
   "* buckets/allocator.c:", 
   "(read_status_t): new structure to record the last read() status from a", 
   "given bucket.", 
   "(TRACK_BUCKET_COUNT): total count of buckets that we'll track within a", 
   "single allocator.", 
   "(track_state_t): all the tracking data for an allocator", 
   "(serf_bucket_alloc_t): add a pointer to the tracking data", 
   "(serf_bucket_allocator_create): create the tracking data", 
   "(find_read_status): find a read status record in the tracking state,", 
   "optionally creating it when not found.", 
   "(serf_debug__record_read): record the last read status for a bucket.", 
   "(serf_debug__entered_loop): verify that all buckets are drained when we", 
   "enter the context loop.", 
   "(serf_debug__closed_conn): clear the tracking information so that we", 
   "don't attempt to validate the state when a connection gets closed.", 
   "(serf_debug__bucket_destroy): ensure that a bucket was fully read by the", 
   "time it is destroyed.", 
   "* context.c:", 
   "(check_buckets_drained): new internal function to verify that all the", 
   "buckets associated with responses were drained before returning to the", 
   "context loop.", 
   "(open_connections): for each open connection with a response bucket,", 
   "ensure that it was fully drained.", 
   "* buckets/buckets.c:", 
   "(serf_default_destroy): call serf_debug__bucket_destroy() to ensure the", 
   "bucket was drained of all input before destruction.", 
   "* test/serf_get.c:", 
   "(main): print the string form of the APR error code from context_run."
  ], 
  "revision_id": "1698485"
 }, 
 {
  "author": "gstein", 
  "date": "2004-09-05T11:18:48.610040Z", 
  "msg": [
   "Break the allocator stuff out into its own file. Some future work will add", 
   "a lot to this, so we don't want buckets.c getting overwhelmed.", 
   "* buckets/allocator.c: new file containing bucket allocator code.", 
   "* buckets/buckets.c: allocator code removed.", 
   "* Makefile: add new file"
  ], 
  "revision_id": "1698484"
 }
]