[
 {
  "author": "cutting", 
  "date": "2004-09-23T16:59:10.000000Z", 
  "msg": [
   "Compile most of Lucene's core code with a single call to gcj.  This", 
   "permits more cross-class inlining.  In particular, the final method", 
   "PriorityQueue.size() can inline, which speeds things 7.5% in my", 
   "benchmarks.  Note that 'final' declarations *do* sometimes make things", 
   "faster in GCJ.  So let's not remove them all!"
  ], 
  "revision_id": "150534"
 }, 
 {
  "author": "cutting", 
  "date": "2004-09-23T16:43:47.000000Z", 
  "msg": [
   "Remvoe dead code that GCJ doesn't like."
  ], 
  "revision_id": "150533"
 }, 
 {
  "author": "cutting", 
  "date": "2004-09-23T16:42:44.000000Z", 
  "msg": [
   "Add an import so that GCJ can compile this."
  ], 
  "revision_id": "150532"
 }, 
 {
  "author": "cutting", 
  "date": "2004-09-22T18:32:27.000000Z", 
  "msg": [
   "Add GCJ native code for SegmentTermDocs.read(int[],int[]) to accellerate TermScorer.  TermScorer and BooleanScorer are now usually a bit faster under GCJ than under Sun's JVM."
  ], 
  "revision_id": "150531"
 }, 
 {
  "author": "cutting", 
  "date": "2004-09-22T18:18:27.000000Z", 
  "msg": [
   "Inline decodeNorm() in TermQuery to make searches faster in Java implementations, like GCJ, where simple methods are not inlined."
  ], 
  "revision_id": "150530"
 }
]