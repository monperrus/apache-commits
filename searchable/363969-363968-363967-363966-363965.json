[
 {
  "author": "brj", 
  "date": "2004-07-23T11:49:46.000000Z", 
  "msg": [
   "added testcase for Criteria#addSql"
  ], 
  "revision_id": "363969"
 }, 
 {
  "author": "arminw", 
  "date": "2004-07-23T11:40:03.000000Z", 
  "msg": [
   "patch by Charles Anthony:", 
   "after fire a fireBrokerEvent() set 'target object' to null", 
   "<snip>", 
   "Anyway, OJB is holding on to far less of our objects - but it still is, a", 
   "bit. All the PBLifeCycleEvents on PersistenceBrokerAbstractImpl (e.g.", 
   "BEFORE_STORE_EVENT) have a target attribute, which is set when an event is", 
   "fired, but never cleared. As Brokers are pooled, the targets are prevented", 
   "from gc'd.", 
   "I've modified RsIterator and PersistenceBrokerImpl to reset the target after", 
   "firing the event. I'm sure there is a better solution [2], but the simple", 
   "approach works.", 
   "</snip>"
  ], 
  "revision_id": "363968"
 }, 
 {
  "author": "arminw", 
  "date": "2004-07-23T11:36:00.000000Z", 
  "msg": [
   "bug fix by Sergey Udovenko,", 
   "AnonymousPersistentFieldForInheritance now use factory methods for pc objects too.", 
   "<snip>", 
   "I guess that I'm getting it because the base class supposed to be created by", 
   "the factory as well (ctor is protected).", 
   "The problem is in method AnonymousPersistentFieldForInheritance.get() that", 
   "uses ClassHelper.newInstance(cld.getBaseClass()); to create that base class.", 
   "</snip>"
  ], 
  "revision_id": "363967"
 }, 
 {
  "author": "arminw", 
  "date": "2004-07-23T11:33:23.000000Z", 
  "msg": [
   "add fix + test case by Charles Anthony.", 
   "Now we always check if object has changed"
  ], 
  "revision_id": "363966"
 }, 
 {
  "author": "arminw", 
  "date": "2004-07-23T11:31:24.000000Z", 
  "msg": [
   "add new test case, query extent objects"
  ], 
  "revision_id": "363965"
 }
]